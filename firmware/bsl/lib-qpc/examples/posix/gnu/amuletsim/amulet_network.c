/*****************************************************************************
* Model: amulet_network.qm
* File:  ./amulet_network.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/3/0) .................................................................*/
#include <stdlib.h>

#include "amulet_network.h"


/* Active object class -----------------------------------------------------*/
/* @(/2/0) .................................................................*/
typedef struct AmuletNetworkTag {
/* protected: */
    QActive super;

/* private: */

    // Process the next message on the queue
    // Note that this time event should only be enabled while the que has something in it
    // when the que is empty this event should not be trigered
    QTimeEvt processNextEvt;
} AmuletNetwork;
extern int8_t AmuletNetwork_calls;
extern ipcMessage * AmuletNetwork_outgoingQueue;

/* protected: */
static QState AmuletNetwork_initial(AmuletNetwork * const me, QEvt const * const e);
static QState AmuletNetwork_NetworkEnabled(AmuletNetwork * const me, QEvt const * const e);



//void QF_onClockTick(void) {
//    QF_TICK((void *)0);
//}


/* Local objects -----------------------------------------------------------*/
static AmuletNetwork l_amulet_network; /* the single instance of the AmuletNetwork active object */


/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_AmuletNetwork = &l_amulet_network.super; /* "opaque" AO pointer */

static uint8_t pos[2];
static ipcMessage *outMessageHead = NULL;
static uint16_t lastMessageID;
//static ipcMessage *inMessageHead = NULL;

/* @(/2/2) .................................................................*/
void AmuletNetwork_ctor(void) {
    AmuletNetwork *me = (AmuletNetwork *)AO_AmuletNetwork;
    QActive_ctor(&me->super, (QStateHandler)&AmuletNetwork_initial);
    QTimeEvt_ctor(&me->processNextEvt, SEND_MESSAGE_FROM_QUEUE_SIG);

    pos[0] = 0;
    pos[1] = 0;

    lastMessageID = 0;

    //outQueue.messages = outMessagePool;
    //outQueue.nmessages = 0;
    //outQueue.head = 0;

    //inQueue.messages = inMessagePool;
    //inQueue.nmessages = 0;
    //inQueue.head = 0;
}

/* @(/2/0) .................................................................*/
int8_t AmuletNetwork_calls;
ipcMessage * AmuletNetwork_outgoingQueue;
/* @(/2/0/3) ...............................................................*/
/* @(/2/0/3/0) */
static QState AmuletNetwork_initial(AmuletNetwork * const me, QEvt const * const e) {
    QTimeEvt_postEvery(&me->processNextEvt, (QActive *)me, 2*BSP_TICKS_PER_SEC);
    return Q_TRAN(&AmuletNetwork_NetworkEnabled);
}
/* @(/2/0/3/1) .............................................................*/
static QState AmuletNetwork_NetworkEnabled(AmuletNetwork * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/2/0/3/1/0) */
        case ADD_MESSAGE_TO_QUEUE_SIG: {
            //Add a message to the queue
            ipcMessage *mewMessage = NULL;

            mewMessage = (ipcMessage *) malloc(sizeof(ipcMessage));

            lastMessageID++;

            mewMessage->messageID = lastMessageID;//Q_EVT_CAST(AmuletNetworkEvt)->messageID;
            //4 start, 4 end, 1 major type
            //2 len, 1 minor type, 1 target id
            //2 params, 1 crc
            mewMessage->majorType = Q_EVT_CAST(AmuletNetworkEvt)->majorType;
            mewMessage->minorType = Q_EVT_CAST(AmuletNetworkEvt)->minorType;
            mewMessage->targetID = Q_EVT_CAST(AmuletNetworkEvt)->targetID;
            mewMessage->configParams = Q_EVT_CAST(AmuletNetworkEvt)->params;
            mewMessage->nparams = Q_EVT_CAST(AmuletNetworkEvt)->nparams;
            mewMessage->next = NULL;

            if(NULL == outMessageHead) {
                outMessageHead = mewMessage;
            } else {
                enqueue(outMessageHead, mewMessage);
            }

            status_ = Q_TRAN(&AmuletNetwork_NetworkEnabled);
            break;
        }
        /* @(/2/0/3/1/1) */
        case SEND_MESSAGE_FROM_QUEUE_SIG: {
            //Grab a message from the queue and send it:
            /*
            if(0 == (AmuletNetwork_calls % 2)){
                LedOn(ACTLED1);
            } else {
                LedOff(ACTLED1);
            }
            //&me->calls = &me->calls + 1;
            AmuletNetwork_calls++;
            */

            ipcMessage *topMessage = NULL;
            topMessage = outMessageHead;
            //uint8_t messageBytes[20];

            //UART0Send("check\r\n",7);

            //only when there is a message in the queue:
            if(outMessageHead != NULL) {
            //UART0Send("something\r\n",11);
                if(0 == (pos[0] % 2)){
                    LedOn(ACTLED1);
                } else {
                    LedOff(ACTLED1);
                }
                pos[0] = pos[0]+1;

                outMessageHead = outMessageHead->next;
                topMessage->next = NULL;

                ipcSend(topMessage);
                //Now put it pack in the queue, and remove
                //it only after it has been acked
                if(NULL == outMessageHead) {
                    outMessageHead = topMessage;
                } else {
                    enqueue(outMessageHead, topMessage);
                }

                //messageToBytes(&topMessage, messageBytes);
                //UART0Send(messageBytes, 19);

            }

            //uint8_t params[1] = {1};
            //uint8_t sensor = Q_EVT_CAST(AmuletSensorsEvt)->sensor_id;
            //uint8_t caller = Q_EVT_CAST(AmuletSensorsEvt)->caller_id;
            //SubscribeInternalSensor(sensor, params, 1, 0, 1, 0, caller);
            status_ = Q_TRAN(&AmuletNetwork_NetworkEnabled);
            break;
        }
        /* @(/2/0/3/1/2) */
        case INCOMMING_ACK_SIG: {
            //Remove message to the queue
            uint16_t ackMessageID = Q_EVT_CAST(AmuletNetworkEvt)->messageID;

            outMessageHead = removeElement(outMessageHead, ackMessageID);

            status_ = Q_TRAN(&AmuletNetwork_NetworkEnabled);
            break;
        }
        /* @(/2/0/3/1/3) */
        case INCOMMING_NACK_SIG: {
            status_ = Q_TRAN(&AmuletNetwork_NetworkEnabled);
            break;
        }
        /* @(/2/0/3/1/4) */
        case INCOMMING_EVT_SIG: {
            status_ = Q_TRAN(&AmuletNetwork_NetworkEnabled);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}


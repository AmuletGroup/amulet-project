/*****************************************************************************
* Model: requests_demo.qm
* File:  ..//requests_demo.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/* @(/2/0) .................................................................*/
#include <stdlib.h>


#include "requests_demo.h"


#ifdef REQUESTS_DEMO_APP

/**
* Simple application for evaluation section
*/

/* Active object class -----------------------------------------------------*/
/* @(/1/0) .................................................................*/
typedef struct RequestsDemoTag {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt timeEvt;
} RequestsDemo;

/* protected: */
static QState RequestsDemo_initial(RequestsDemo * const me, QEvt const * const e);
static QState RequestsDemo_off(RequestsDemo * const me, QEvt const * const e);
static QState RequestsDemo_on(RequestsDemo * const me, QEvt const * const e);



/* Local objects -----------------------------------------------------------*/
static RequestsDemo l_requests_demo; /* the single instance of the Table active object */


/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_RequestsDemo = &l_requests_demo.super; /* "opaque" AO pointer */

/* @(/1/2) .................................................................*/
void RequestsDemo_ctor(void) {
    RequestsDemo *me = (RequestsDemo *)AO_RequestsDemo;
    QActive_ctor(&me->super, (QStateHandler)&RequestsDemo_initial);
    QTimeEvt_ctor(&me->timeEvt, REQ_CHANGE_SIG);


}

/* @(/1/0) .................................................................*/
/* @(/1/0/1) ...............................................................*/
/* @(/1/0/1/0) */
static QState RequestsDemo_initial(RequestsDemo * const me, QEvt const * const e) {
    QTimeEvt_postEvery(&me->timeEvt, (QActive *)me, BSP_TICKS_PER_SEC/4);

    /*
    //Subscribe to button events
    AmuletSensorsEvt *button1Evt;
    AmuletSensorsEvt *button2Evt;
    button1Evt = Q_NEW(AmuletSensorsEvt, SUBSCRIBE_INTERNAL_SENSOR_SIG);
    button1Evt->sensor_id =  BUTTONA;
    button1Evt->caller_id = HELLO_APP;
    button2Evt = Q_NEW(AmuletSensorsEvt, SUBSCRIBE_INTERNAL_SENSOR_SIG);
    button2Evt->sensor_id =  BUTTONB;
    button2Evt->caller_id = HELLO_APP;
    QACTIVE_POST(AO_AmuletSensors, &button1Evt->super, me);
    QACTIVE_POST(AO_AmuletSensors, &button2Evt->super, me);

    QActive_subscribe(&me->super, BUTTON_A_PRESSED_SIG);
    QActive_subscribe(&me->super, BUTTON_B_PRESSED_SIG);
    */


    return Q_TRAN(&RequestsDemo_off);
}
/* @(/1/0/1/1) .............................................................*/
static QState RequestsDemo_off(RequestsDemo * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/0/1/1) */
        case Q_ENTRY_SIG: {
            //DIRECTED Message
            AmuletActuatorsEvt *ledEvt;

            ledEvt = Q_NEW(AmuletActuatorsEvt, LEDOFF_SIG);
            ledEvt->led_id =  ACTLED3;
            QACTIVE_POST(AO_AmuletActuators, &ledEvt->super, me);

            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/1/0) */
        case REQ_CHANGE_SIG: {
            status_ = Q_TRAN(&RequestsDemo_on);
            break;
        }
        /* @(/1/0/1/1/1) */
        case BUTTON_A_PRESSED_SIG: {
            AmuletActuatorsEvt *displayEvt;
            uint8_t * dmessage = "buttona \r\n";
            displayEvt = Q_NEW(AmuletActuatorsEvt, DISPLAY_MESSAGE_SIG);
            displayEvt->message = dmessage;
            displayEvt->message_len = 10;
            QACTIVE_POST(AO_AmuletActuators, &displayEvt->super, me);
            status_ = Q_TRAN(&RequestsDemo_off);
            break;
        }
        /* @(/1/0/1/1/2) */
        case BUTTON_B_PRESSED_SIG: {
            AmuletActuatorsEvt *displayEvt;
            uint8_t * dmessage = "buttonb \r\n";
            displayEvt = Q_NEW(AmuletActuatorsEvt, DISPLAY_MESSAGE_SIG);
            displayEvt->message = dmessage;
            displayEvt->message_len = 10;
            QACTIVE_POST(AO_AmuletActuators, &displayEvt->super, me);


            //Ask amulet to turn led off
            //AmuletActuatorsEvt *ledEvt;

            //ledEvt = Q_NEW(AmuletActuatorsEvt, LEDOFF_SIG);
            //ledEvt->led_id =  ACTLED2;
            //QACTIVE_POST(AO_AmuletActuators, &ledEvt->super, me);


            ///Do not call the BSP directly:
            //BSP_ledOff();

            ///Publish-subscribe message:
            //AmuletActuatorsEvt *ledEvt;
            //ledEvt = Q_NEW(AmuletActuatorsEvt, LEDOFF_SIG);
            //QF_PUBLISH(&ledEvt->super, me);

            // Using the ExternalSensorManager
            ExternalSensorsRequestEvt *subscriptionEvt;
            subscriptionEvt = Q_NEW(ExternalSensorsRequestEvt, SUBSCRIBE_EXT_SENSOR_SIG);
            subscriptionEvt->device_id = HRM;
            subscriptionEvt->expiration = 0;
            subscriptionEvt->window_size = 1;
            subscriptionEvt->window_interval = 1;
            subscriptionEvt->caller_id = REQUESTS_DEMO_APP;
            QACTIVE_POST(AO_AmuletExternalSensors, &subscriptionEvt->super, me);

            /*
            //Also for testing purposes:
                        //Generate an IPC message:
                        //uint8_t messageParameters[3] = { 1, 2, 3 };
                        uint8_t * messageParameters = malloc(3);
                        //TODO: Make sure this memory gets freed when the corresponding IPC message
                        //has been acked.
                        messageParameters[0] = 1;
                        messageParameters[1] = 2;
                        messageParameters[2] = 3;
                        //uint8_t messageBytes[19];

                        AmuletNetworkEvt *testMessageEvt;
                        testMessageEvt = Q_NEW(AmuletNetworkEvt, ADD_MESSAGE_TO_QUEUE_SIG);
                        testMessageEvt->majorType = IPC_REQUEST;
                        testMessageEvt->minorType = SUBSCRIBE_INTERNAL_SENSOR;
                        testMessageEvt->targetID = INT_SENSOR_MAN_M0;
                        testMessageEvt->params = messageParameters;
                        testMessageEvt->nparams = 3;
                        QACTIVE_POST(AO_AmuletNetwork, &testMessageEvt->super, NULL);
            */

            status_ = Q_TRAN(&RequestsDemo_off);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/* @(/1/0/1/2) .............................................................*/
static QState RequestsDemo_on(RequestsDemo * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* @(/1/0/1/2) */
        case Q_ENTRY_SIG: {
            //DIRECTED message:
            AmuletActuatorsEvt *ledEvt;
            uint8_t *auth = malloc(1);
            ledEvt = Q_NEW(AmuletActuatorsEvt, LEDON_SIG);
            ledEvt->led_id =  ACTLED3;
            auth[0] = 1;
            ledEvt->authorization = auth;

            QACTIVE_POST(AO_AmuletActuators ,&ledEvt->super, me);
            status_ = Q_HANDLED();
            break;
        }
        /* @(/1/0/1/2/0) */
        case REQ_CHANGE_SIG: {
            status_ = Q_TRAN(&RequestsDemo_off);
            break;
        }
        /* @(/1/0/1/2/1) */
        case BUTTON_A_PRESSED_SIG: {
            AmuletActuatorsEvt *displayEvt;
            uint8_t * dmessage = "buttona \r\n";
            displayEvt = Q_NEW(AmuletActuatorsEvt, DISPLAY_MESSAGE_SIG);
            displayEvt->message = dmessage;
            displayEvt->message_len = 10;
            QACTIVE_POST(AO_AmuletActuators, &displayEvt->super, me);
            status_ = Q_TRAN(&RequestsDemo_on);
            break;
        }
        /* @(/1/0/1/2/2) */
        case BUTTON_B_PRESSED_SIG: {
            AmuletActuatorsEvt *displayEvt;
            uint8_t * dmessage = "buttonb \r\n";
            displayEvt = Q_NEW(AmuletActuatorsEvt, DISPLAY_MESSAGE_SIG);
            displayEvt->message = dmessage;
            displayEvt->message_len = 10;
            QACTIVE_POST(AO_AmuletActuators, &displayEvt->super, me);


            //Also for testing purposes:
            //Subscribe to the HRM sensor.


            // Using the ExternalSensorManager
            ExternalSensorsRequestEvt *subscriptionEvt;
            subscriptionEvt = Q_NEW(ExternalSensorsRequestEvt, SUBSCRIBE_EXT_SENSOR_SIG);
            subscriptionEvt->device_id = HRM;
            subscriptionEvt->expiration = 0;
            subscriptionEvt->window_size = 1;
            subscriptionEvt->window_interval = 1;
            subscriptionEvt->caller_id = REQUESTS_DEMO_APP;
            QACTIVE_POST(AO_AmuletExternalSensors, &subscriptionEvt->super, me);

            /** Using the NetworkManager

            //This requires 8 parameters:
            //device_id, expiration, window_size, window_interval, caller_id
            //HRM, 0x0000, 0x0001,0x0001,0x01
            uint8_t * messageParameters = malloc(8);
            //TODO: Make sure this memory gets freed when the corresponding IPC message
            //has been acked.
            messageParameters[0] = HRM;
            messageParameters[1] = 0;
            messageParameters[2] = 0;
            messageParameters[3] = 1;
            messageParameters[4] = 0;
            messageParameters[5] = 1;
            messageParameters[6] = 0;
            messageParameters[7] = 1;

            AmuletNetworkEvt *testMessageEvt;
            testMessageEvt = Q_NEW(AmuletNetworkEvt, ADD_MESSAGE_TO_QUEUE_SIG);
            testMessageEvt->majorType = IPC_REQUEST;
            testMessageEvt->minorType = SUBSCRIBE_EXTERNAL_SENSOR;
            testMessageEvt->targetID = EXT_SENSOR_MAN_M0;
            testMessageEvt->params = messageParameters;
            testMessageEvt->nparams = 8;
            QACTIVE_POST(AO_AmuletNetwork, &testMessageEvt->super, NULL);

            */
            status_ = Q_TRAN(&RequestsDemo_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}


#endif //RERQUESTS_DEMO_APP

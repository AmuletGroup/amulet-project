/**
 *  @file amulet.h
 *  @brief Main header that contains contains prototypes for the Amulet API,
 *  macros, constants, and global variables that app developers will need.
 */
#ifndef AMULET_H
#define AMULET_H

#include <math.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * QP Includes.
 */
#include "qp_port.h"

/**
 * BSP Includes.
 */
#include "bsp_setup.h"

/**
 * Amulet (Event Layer) Includes.
 *
 * All other core modules are included below so that files in the upper layer(s)
 * only have to include core.h to access the core.
 */
#include "amulet_datatypes.h"

#include "analytics.h"
#include "core_algorithm.h"
#include "core_app_manager.h"
#include "core_clock.h"
#include "core_graph.h"
#include "core_message.h"
#include "core_mode.h"
#include "core_sensors.h"
#include "core_storage.h"
#include "core_ui.h"


/**
 * Definition for how many interrupts are generated per second on the MSP430.
 */
#define AMULET_TICKS_PER_SEC 20U // 32768U

/**
 * Address of UUID
 */
#define AMULET_UUID_ADDR 0x1A30


/**
 * Every app should be defined with a "type" -- TYPE_UNDEFINED by default.
 * The amulet system is especially interested in identifying the "emergency"
 * app(s).
 *
 * @note There should ideally be some mechanism to prevent just any app from
 * identifying as an "emergency" type application since these applications have
 * special privileges when compared to other types of applications.
 */
typedef enum types {
  TYPE_UNDEFINED = 0x00,   /**< The app's "type" doesn't fit into any other type
                              category (default) */
  TYPE_DEBUG_APP = 0x01,   /**< Debug/test realated app */
  TYPE_HEALTH_APP = 0x02,  /**< Health realated app */
  TYPE_FITNESS_APP = 0x04, /**< Fitness related app */
  TYPE_SAFETY_APP = 0x08,  /**< Safety related app */
  TYPE_EMA_APP = 0x10,     /**< An Ecological Momentary Assessment (EMA) app */
  TYPE_SYSTEM_APP = 0x20,  /**< An app meant to convey system information or
                              improve system functionality */
  TYPE_EMERGENCY_APP =
      0x40 /**< A special app meant to handle emergency situations */
} AppType;

/**
 * This ClockType is used to get value of data and time (see: AmuletClock()).
 */
typedef enum clocktypes {
  YEAR = 0x00,
  MONTH = 0x01,
  DAY = 0x02,
  HOUR = 0x04,
  MINUTE = 0x08,
  SECOND = 0x10,
  WEEKDAY = 0x12
} ClockType;

/**
 * Used for UI to set Fonts
 */
typedef enum fonttypes {
  BOLD_FONT = 0x00,
  MEDIUM_FONT = 0x01,
  REGULAR_FONT = 0x02
} FontType;

/**
 * Used for UI to get the font sizes
 */
typedef enum fonttsizes {
  BOLD_FONT_SIZE = 22,
  MEDIUM_FONT_SIZE = 16,
  REGULAR_FONT_SIZE = 12
} FontSize;

/**
 * Used by AmuletGetHRandRRI() for type of data being requested.
 */
typedef enum HRM_DATA {
    HRM_HR = 0,
    HRM_RRI1 = 1,
    HRM_RRI2 = 2,
    HRM_RRI3 = 3,
    HRM_RRI4 = 4,
    HRM_RRI5 = 5,
    HRM_RRI6 = 6,
    HRM_RRI7 = 7,
    HRM_ENERGY = 8,
    HRM_CONTACT = 9
} hrmdata;


/* ************************************************************************** *
 *                             Amulet System Signals                          *
 * ************************************************************************** */

/**
 * The value for the first Amulet OS internal signal.
 *
 * @note It is important to note that the Amulet system runs atop the QP
 * framework, an event driven framework composed of concurrent finite state
 * machines; To transition between different states in the state machines,
 * signals are generated and sent to applications. The application-level signals
 * do not start from 0, however, but are offset by the constant Q_USER_SIG (this
 * is because QP reserves the lowest few signals for internal use and provides
 * this constant as an offset from which user-level signals can start). The
 * internal Amulet system signals will start at Q_USER_SIG; Amulet applications
 * can start defining signals at
 */
#define AMULET_INTERNAL_Q_SIG_START_SIG Q_USER_SIG

/**
 * CoreSignals are signals generated by the core layer that are available to
 * the amulet system, but not applications.
 */
enum CoreSignal {
  CORE_STIMER_SIG = AMULET_INTERNAL_Q_SIG_START_SIG,
  CORE_CTIMER_SIG,
  CORE_NOTIFY_OTHER_SIG,
  CORE_LOG_APPEND_SIG,
  CORE_LOG_READ_SIG,
  __END_OF_CORE_SIGNALS
};

/**
 * AmuletSignals are signals generated by the event layer that are available
 * to all applications.
 */
enum AmuletSignal {
  AMULET_DEVICE_DATA_XL_SIG = __END_OF_CORE_SIGNALS,
  AMULET_DEVICE_DATA_IMU_SIG,
  AMULET_DEVICE_DATA_HR_SIG,
  AMULET_DEVICE_DATA_SIG,
  AMULET_REQ_CHANGE_SIG, // (timer signal)
  AMULET_BUTTON_TAP_SIG,
  AMULET_BUTTON_HOLD_SIG,
  AMULET_BOTH_HOLD_SIG,
  AMULET_BATTERY_CHANGE_SIG,
  AMULET_LOW_BATTERY_SIG,
  AMULET_APPEND_SUCCESS_SIG,
  AMULET_APPEND_FAIL_SIG,
  AMULET_READ_SUCCESS_SIG,
  AMULET_READ_FAIL_SIG,
  AMULET_SLIDER_UP_SIG,
  AMULET_SLIDER_DOWN_SIG,
  __END_OF_AMULET_SIGNALS
};

/**
 * The value for the first Amulet OS application signal.
 */
#define AMULET_APPLICATIONS_Q_SIG_START_SIG __END_OF_AMULET_SIGNALS

/* ************************************************************************** *
 *                                 Amulet Events                              *
 * ************************************************************************** */

/**
 * QM structure for representing a generic amulet event.
 */
typedef struct { QEvt super; } AmuletEvt;

/**
 * QM structure for representing button related events.
 */
typedef struct {
  QEvt super;
  uint8_t buttonId;
} AmuletButtonEvt;

/**
 * QM structure for representing sensor related events.
 */
typedef struct {
  QEvt super;
  // uint8_t imu_a;
  // uint8_t imu_b;
  // uint8_t imu_c;
  // uint16_t expiration;
  // uint16_t window_size;
  uint8_t sensor_id;
  // uint16_t window_interval;
  // uint8_t caller_id;
  uint8_t *data;
  uint8_t sensor_type;
  uint16_t length;
} AmuletSensorsEvt;

/* ************************************************************************** *
 *                                Amulet Resources                            *
 * ************************************************************************** */

/**
 * Internal Amulet Resources (Sensors) that are available on the amulet (both
 * on the communication board as well as the app board).
 * @note Resources that do not need to be subscribed to: DISPLAY, BUTTONS,
 * LEDS, HAPTICBUZZER, CAPTOUCH, SDCARD
 */
enum InternalResource {
  LIGHT, // Light sensor located on the MSP430
  IMU,   // IMU located on the MSP430 (Includes ACCELEROMETER, GYROSCOPE, and
         // MAGNETOMETER)
  ACCELEROMETER = 4, // Low-power accelerometer located on the M0
  AUDIO,             // Microphone located on the MSP430
  TEMPERATURE,       // Temperature sensor located on the MSP430
  TIMER = 21,        // Timer service provided by amulet-os/QM
  BATTERY            // Battery from adc
};

/**
 * Analytical Amulet Resources (Sensors) that are available on the amulet (both
 * on the communication board as well as the app board).
 */
enum AnalyticsResource { BLE_EVENT = 1, UI_EVENT = 2 };

/**
 * External Amulet Resources (Sensors) that are available on the amulet (both
 * on the communication board as well as the app board).
 */
enum ExternalResource {
  HEARTRATE = 132, // External heart rate sensor (Mio or Zephyr HR devices)
  RUNNING_SPEED =
      133 // External running speed, cadence, stride, and distance (BLE devices)
};

// RESOURCES THAT DON'T NEED TO BE SUBSCRIBED TO:
// - DISPLAY -- each app can use the display, but only the "front" app has
// control of the display; the only exception is that each app can optionally
// specify a "status" in the status (top) line of the display.
// - BUTTONS -- each app will receive button press (tap) events. the button hold
// event, currently, is special and is only sent to the emergency response
// application
// - LEDs -- each app can use the LEDs. we currently don't have rules defined
// for who can use the LEDs...first come, first serve; preemption is possible.
// - HAPTICBUZZER -- each app can use the haptic buzzer; again, no rules
// defined.
// - THUMBWHEEL -- each app can use the thumb wheel; again, no rules defined.
// - SDCARD -- each app can use the SD card; each app currently has one log just
// for itself (the aft automatically creates a LOG ID for each app based on the
// apps present in the firmware).

/* ************************************************************************** *
 *                                   SENSORS
 * ************************************************************************** */

/**
 * Subscribe to a particular sensor and specify configuration parameters.
 *
 * @code
 * AmuletSubscribeInternalSensor(ACCELEROMETER, 0, 0, 0, 0, 0);
 * @endcode
 *
 * @note For all deprecated arguments, just pass 0. The interface for sensor
 * subscriptions is currently defined for more fine-grained control which is
 * not yet implemented. Only the desired sensor to subscribe to needs to be
 * specified.
 *
 * @param sensor_id The sensor to subscribe to (defined in amulet.h).
 * @param expiration (depreciated) The Sensor Manager will stop sending data and
 * events after this expiration (in seconds).
 * @param window_size (depreciated) The sampling window size (in seconds).
 * @param window_interval (depreciated) The sampling interval (in seconds); must
 * be greater than or equal to the window_size.
 *
 * @return None.
 */
void AmuletSubscribeInternalSensor(uint8_t sensor_id, uint16_t expiration,
                                   uint16_t window_size,
                                   uint16_t window_interval, uint8_t requestor);

/**
 * Unsubscribe from a particular sensor
 *
 * @code
 * AmuletUnsubscribeInternalSensor(ACCELEROMETER);
 * @endcode
 *
 * @param sensor_id The sensor to subscribe to (defined in amulet.h).
 */
void AmuletUnsubscribeInternalSensor(uint8_t sensor_id, uint8_t requestor);

/**
 * Get the current heart rate (HR). Once subscribed to the HR sensor
 * (see: AmuletSubscribeInternalSensor), the  DEVICE_DATA_HR signal will be sent
 * every time there are new HR samples available.
 *
 * @return The current heart rate as a uint8_t.
 */
uint16_t AmuletGetHR(uint8_t requestor);

/**
 * Get the battery reading from the battery adc
 *
 * @return battery percent returned as a uint8_t.
 */
uint8_t AmuletGetBatteryLevel(uint8_t requestor);

/**
 * Get the light reading from the light sensor
 *
 * @return Acceleration data returned as a uint16_t.
 */
uint16_t AmuletGetLightLevel(uint8_t requestor);

/**
 * Get the temperature from the temp sensor
 *
 * @return temperature data returned as a uint16_t.
 */
uint16_t AmuletGetTemperature(uint8_t requestor);

/**
 * Get the audio level from the microphone
 *
 * @return audio data returned as a uint16_t.
 */
uint16_t AmuletGetAudio(uint8_t requestor);

/**
 * Get the adc value from the passed sensor
 *
 * @return adc data returned as a uint16_t.
 */
uint16_t AmuletGetADC(enum InternalResource ir, uint8_t requestor);

/**
 * Get analytics results from the underlying platform about user interactinos
 * and BLE
 *
 * @return the analytics value since this was last called for the internal
 * resource
 */
uint16_t AmuletAnalytics(enum AnalyticsResource ir, uint8_t requestor);

/**
 * Status of BLE pairing
 * @return true if BLE is paired, false if not
 */
bool AmuletIsBLEPaired();

/**
 * Get acceleration along the x axis.
 *
 * @return Acceleration data returned as a uint16_t.
 */
int16_t AmuletGetAccelX(uint8_t idx, uint8_t requestor);

/**
 * Get acceleration along the y axis.
 *
 * @return Acceleration data returned as a uint16_t.
 */
int16_t AmuletGetAccelY(uint8_t idx, uint8_t requestor);

/**
 * Get acceleration along the z axis.
 *
 * @return Acceleration data returned as a uint16_t.
 */
int16_t AmuletGetAccelZ(uint8_t idx, uint8_t requestor);

/**
 * Get gyro along the x axis.
 *
 * @return Gyro data returned as a uint16_t.
 */
int16_t AmuletGetGyroX(uint8_t idx, uint8_t requestor);

/**
 * Get gyro along the y axis.
 *
 * @return Gyro data returned as a uint16_t.
 */
int16_t AmuletGetGyroY(uint8_t idx, uint8_t requestor);

/**
 * Get gyro along the z axis.
 *
 * @return Gyro data returned as a uint16_t.
 */
int16_t AmuletGetGyroZ(uint8_t idx, uint8_t requestor);


/* ************************************************************************** *
 *                                   CLOCK
 * ************************************************************************** */

/**
 * Get time/date information.
 *
 * @code
 * // Get today's date (day/month/year)
 * uint8_t day = AmuletClock(DAY);
 * uint8_t month = AmuletClock(MONTH);
 * uint8_t year = AmuletClock(YEAR);
 * @endcode
 *
 * @param type Available types are YEAR, MONTH, DAY, HOUR, MINUTE, SECOND,
 WEEKDAY.
 *
 * @return The corresponding value according to the amulet system (NOTE: WEEKDAY
 and MONTH is zero-based).
 */
uint8_t AmuletClock(ClockType type, uint8_t requestor);

/**
 * Set time/date information.
 *

 * @code
 * // Set today's date (day/month/year)
 * AmuletSetClock(DAY, day);
 * AmuletSetClock(MONTH, month);
 * AmuletSetClock(YEAR, year);
 * @endcode
 *
 * @param type Available types are YEAR, MONTH, DAY, HOUR, MINUTE, SECOND,
 WEEKDAY.
 *
 * @return The corresponding value according to the amulet system (NOTE: WEEKDAY
 and MONTH is zero-based).
 */
void AmuletSetClock(ClockType type, uint16_t value, uint8_t requstor);

/**
 * Get a text representation for the current time.
 *
 * @param target An array where the "time" text can be written.
 *
 * @return None.
 */
void AmuletDateTimeText(__char_array target, uint8_t requestor);

/**
 * Get a text representation for the clock (date, weekday, and time) in this
 moment.
 *
 * @code
 * uint8_t emode1[13];
 * uint8_t emode2[13];
 * uint8_t emode3[15];
 * AmuletClockText(emode1,emode2,emode3);
 * AmuletDisplayMessage(emode1, 4);
 * @endcode
 *
 * @param target1 An array where the "Date" text can be written.
 * @param target2 An array where the "Weekday" text can be written.
 * @param target3 An array where the "Time" text can be written.
 *
 * @return None.
 */
void AmuletClockText(__char_array target1, __char_array target2,
                     __char_array target3, uint8_t requestor);

/**
 * Get a text representation for the current Date.
 *
 * @param target An array where the "Date" text can be written.
 *
 * @return None.
 */
void AmuletDateText(__char_array target, uint8_t requestor);

/**
 * Get the text representation for the current day of the week.
 *
 * @param target An array where the "Weekday" text can be written.
 *
 * @return None.
 */
void AmuletWeekText(__char_array target, uint8_t requestor);

/* ************************************************************************** *
 *                                   TIMER
 * ************************************************************************** */

/**
 * Set a timer. Once the timer is set, the AMULET_REQ_CHANGE signal will be
 * sent every @param{interval} seconds.
 *
 * @code
 * AmuletTimer(2); //Set timer to notify me every two seconds
 * @endcode
 *
 * @param interval The desired timer interval (in second), in uint16_t type
 *
 * @return None.
 */
void AmuletTimer(uint16_t interval, uint8_t requestor);

/**
 * Cancel a timer that was previously set.
 *
 * @return None.
 */
void AmuletTimerCancel(uint8_t requestor);

/* ************************************************************************** *
 *                                   UI
 * ************************************************************************** */

//
// DISPLAY
//
/**
 * Place large text on the display at some location given by x,y.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletBoldText(uint8_t x, uint8_t y, __char_array message,
                    uint8_t requestor);

/**
 * Place medium text on the display at some location given by x,y.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletMediumText(uint8_t x, uint8_t y, __char_array message,
                      uint8_t requestor);

/**
 * Place small text on the display at some location given by x,y.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletRegularText(uint8_t x, uint8_t y, __char_array message,
                       uint8_t requestor);

/**
 * Place large text centered on the display starting at some position given by y.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletBoldCenteredText(uint8_t y, __char_array message, uint8_t requestor);

/**
 * Place medium text centered on the display starting at some position given by y.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletMediumCenteredText(uint8_t y, __char_array message,
                              uint8_t requestor);

/**
 * Place small text centered on the display starting at some position given by y.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletRegularCenteredText(uint8_t y, __char_array message,
                               uint8_t requestor);

/**
 * Draw an empty rectangle at position x,y with dimensions w,h.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletDrawRect(int16_t x, int16_t y, uint8_t w, uint8_t h,
                    uint8_t requestor);

/**
 * Clear the rectangle at position x,y with dimensions w,h.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletClearRect(int16_t x, int16_t y, uint8_t w, uint8_t h,
                     uint8_t requestor);

/**
 * Fill the rectangle at position x,y with dimensions w,h.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletFillRect(int16_t x, int16_t y, uint8_t w, uint8_t h,
                    uint8_t requestor);

/**
 * Draw a line with start point x0,y0 and end point x1,y1.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletDrawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
                    uint8_t requestor);

/**
 * Draw vertical line on the screen, you should refresh the screen after draw
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletDrawFastVLine(int16_t x, int16_t y, int16_t h, uint8_t requestor);

/**
 * Draw horizontal line on the screen, you should refresh the screen after draw
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletDrawFastHLine(int16_t x, int16_t y, int16_t w, uint8_t requestor);

/**
 * Get the width of text on the display.
 *
 * @return text width.
 */
uint8_t AmuletTextWidth(__char_array message, uint8_t requestor);

/**
 * Get the height of text on the display.
 *
 * @return text height.
 */
uint8_t AmuletTextHeight(uint8_t requestor);

/**
 * Refresh the display.
 *
 * @return None.
 */
void AmuletPushChangesToDisplay(uint8_t requestor);

/**
 * Draw a heart graphic at position x,y.
 *
 * @return None.
 */
void AmuletDrawHeartImage(uint8_t x, uint8_t y, uint8_t requestor);

/**
 * Draw a person walking graphic at position x,y.
 *
 * @return None.
 */
void AmuletDrawWalkerImage(uint8_t x, uint8_t y, uint8_t requestor);

/**
 * Draw sun graphic at position x,y.
 *
 * @return None.
 */
void AmuletDrawSunImage(uint8_t x, uint8_t y, uint8_t requestor);

/**
 * Get the width for drawn graphics.
 *
 * @return width of graphic.
 */
uint8_t AmuletDrawingAreaWidth();

/**
 * Get the height for drawn graphics.
 *
 * @return height of graphic.
 */
uint8_t AmuletDrawingAreaHeight();

/**
 * Define a new graph.
 *
 * @return graph id.
 */
int8_t AmuletAddGraph(GraphType type, uint8_t x, uint8_t y, uint8_t w,
                      uint8_t h, uint8_t data_min, uint8_t data_max,
                      uint8_t requestor);

/**
 * Add data to the graph specified by graph_id.
 *
 * @return None.
 */
void AmuletAddGraphData(uint8_t data, uint8_t graph_id, uint8_t requestor);

/**
 * Draw the graph on the display.
 *
 * @note Must call AmuletPushChangesToDisplay afterwards to see changes.
 *
 * @return None.
 */
void AmuletDrawGraph(uint8_t graph_id, uint8_t requestor);

/**
 * Write text to the application's display buffer.
 *
 * @note An application's display buffer is only rendered when it is the
 * "front" running application.
 *
 * @param message The desired text to display.
 * @param line The line number where the desired text will be written.
 *
 * @return None.
 */
void AmuletDisplayMessage(__char_array message, uint8_t line,
                          uint8_t requestor);

/**
 * Clear the entire display buffer.
 *
 * @return None.
 */
void AmuletDisplayClr(uint8_t requestor);

/**
 * Clear a specific line of the display buffer.
 *
 * @param lineNumber The line on the display to clear.
 *
 * @return None.
 */
void AmuletDisplayClrLN(uint8_t lineNumber, uint8_t requestor);

//
// BUTTONS
//

/**
 * Check the physical location of a particular button on the Amulet.
 *
 * @param id The ID of the button in question.
 * @return an enum value corresponding to the side of the case where the button
 * is located (see: ui.h).
 */
ButtonSide AmuletButtonSide(uint8_t id, uint8_t requestor);

//
// LEDs
//

/**
 * Turn a specific LED off.
 *
 * @param ledId the ID of the LED that is to be turned off (see: LED enum)
 *
 * @return None.
 */
void AmuletLEDOff(LED ledId, uint8_t requestor);

/**
 * Turn a specific LED on.
 *
 * @param ledId the ID of the LED that is to be turned on (see: LED enum)
 *
 * @return None.
 */
void AmuletLEDOn(LED ledId, uint8_t requestor);

/**
 * "Blink" a specific LED.
 *
 * @param ledId the ID of the LED that is to be blinked (see: LED enum)
 *
 * @return None.
 */
void AmuletLEDBlink(LED ledId, uint8_t requestor);

/**
 *
 * Turns on the capacitive touch timers
 * @param requestor [description]
 */
void AmuletTurnOnCapTouch(uint8_t requestor);

/**
 * Turns off the capacitive touch timers
 * @param requestor [description]
 */
void AmuletTurnOffCapTouch(uint8_t requestor);

//
// HAPTIC BUZZER
//

/**
 * Trigger a single, 0.1 second "buzz" from the haptic buzzer.
 *
 * @return None.
 */
void AmuletHapticSingleBuzz(uint8_t requestor);

/**
 * Trigger two back-to-back, 0.1 second "buzz"es from the haptic buzzer.
 *
 * @return None.
 */
void AmuletHapticDoubleBuzz(uint8_t requestor);

/* ************************************************************************** *
 *                                   SYSTEM
 * ************************************************************************** */


/**
 * Each MSP430 has a 128-bit random number written to it's flash at manufacture
 * time. Over a small batch of amulets, there is a high probability that these
 * will be unique. Currently, we just return the first 64-bits.
 *
 * @return uint64_t containing the first 64-bits of the 128-bit tlb random number
 */
uint64_t AmuletGetUUID(uint8_t requestor);

/**
 * Check if app is "front" (i.e., currently has control of the display).
 *
 * @return boolean A boolean value indicating if the requesting app is the
 * "front" app.
 */
bool AmuletIsForegroundApp(uint8_t requestor);

/**
 * Set the current system mode to 'Normal' mode.
 *
 * @return None.
 */
void AmuletEnterNormalMode(uint8_t requestor);

/**
 * Determine if system is in 'Normal' mode.
 *
 * @return boolean indicating if system mode is set to 'Normal' mode.
 */
bool AmuletInNormalMode(uint8_t requestor);

/**
 * Set the current system mode to 'EmergencyMaybe' mode.
 *
 * @return None.
 */
void AmuletEnterEmergencyMaybeMode(uint8_t requestor);

/**
 * Determine if system is in 'EmergencyMaybe' mode.
 *
 * @return boolean indicating if system mode is set to 'EmergencyMaybe' mode.
 */
bool AmuletInEmergencyMaybeMode(uint8_t requestor);

/**
 * Set the current system mode to 'Emergency' mode.
 *
 * @return None.
 */
void AmuletEnterEmergencyMode(uint8_t requestor);

/**
 * Determine if the system is in 'Emergency' mode.
 *
 * @return boolean indicating if system mode is set to 'Emergency' mode.
 */
bool AmuletInEmergencyMode(uint8_t requestor);

/**
 * Set the current system mode to 'Debug' mode.
 *
 * @return None.
 */
void AmuletEnterDebugMode(uint8_t requestor);

/**
 * Determine if the system is in 'Debug' mode.
 *
 * @return boolean indicating if system mode is set to 'Debug' mode.
 */
bool AmuletInDebugMode(uint8_t requestor);

/**
 * Allow a pre-approved app to request to take control of the
 * UI. We don't currently have any rules defining how the OS should grant/deny
 * such requests so for this simple version, control of the UI is *always*
 * granted to the requestor if they have the appropriate permission to make this
 * request (i.e., the app's manifest file contains privilege the necessary
 * privilege to call this function).
 *
 * @return boolean indicating if the foreground app was updated and the display
 *  was refreshed with the new foreground app's display buffer.
 */
bool AmuletRequestMoveToFront(uint8_t requestor);

/* ************************************************************************** *
 *                                   STORAGE
 * ************************************************************************** */

/**
 * Check if the SD card exists.
 *
 * @return return A uint8_t value: 0 means the SD is present, otherwise it does
 * not.
 */
uint8_t AmuletSDPresent(uint8_t requestor);

/**
 * Append a line to your app's log file on the SD card. An AMULET_APPEND_SUCCESS
 * signal will be generated if the log append is successful; likewise an
 * AMULET_APPEND_FAIL signal will be generated if the log append is
 unsuccessful.
 *
 * @note The AFT will auto-fill the logKey and requestor parameters---as part of
 * the AFT firmware generation, app IDs (i.e., the requestor ID) and log IDs
 * (i.e., logKey) are automatically created.
 *
 * @param log_name The log to write to -- this value will be automatically
 inserted
          by the AFT so application developers need not specify this value
 manually.
 * @param line_contents A character array containing the contents to write to
 the log.
 *
 * @return A uint8_t value representing the result of the read: 0 indicates a
 * successful read, while a 1 indicates an unsuccessful read.
 */
uint8_t AmuletLogAppend(uint8_t log_name, __char_array line_contents,
                        uint8_t requestor);

void AmuletStartLogTransaction();

uint8_t AmuletCommitLogTransaction();

/**
 * Append data to your app's log file on the SD card. An AMULET_APPEND_SUCCESS
 * signal will be generated if the log append is successful; likewise an
 * AMULET_APPEND_FAIL signal will be generated if the log append is
 unsuccessful.
 *
 * @note The AFT will auto-fill the logKey and requestor parameters---as part of
 * the AFT firmware generation, app IDs (i.e., the requestor ID) and log IDs
 * (i.e., logKey) are automatically created.
 *
 * @return A uint8_t value representing the result of the read: 0 indicates a
 * successful read, while a 1 indicates an unsuccessful read.
 */
uint8_t AmuletLogData(uint16_t logid, __char_array value_headers, __float_array data,
                      uint8_t requestor);


/* ************************************************************************** *
 *                                 QP WRAPPERS
 * ************************************************************************** */

/**
 * Send a signal to explicitly transition to another state defined in this
 * application's finite state machine (FSM).
 *
 * @note The AFT will auto-fill the 'me' and 'requestor' parameters so the
 * application developer need not know/supply those details.
 * @note This function prevents applications from having to write code that
 * is dependent on the underlying state machine implementation.
 *
 * @param sig The signal that is to be posted.
 *
 * @return None.
 */
void AmuletStateTransition(QActive *const me, int sig, uint8_t requestor);

/* ************************************************************************** *
 *                          UTILITY & DEBUG FUNCTIONS
 * ************************************************************************** */


void AmuletWrapText(__char_array target, uint16_t wrapline, uint8_t requestor);

/**
 * Converts an integer value to a null-terminated string using the specified
 * base
 * and stores the result in the array given by the 'target' parameter.
 *
 * @note AmuletITOA is merely a wrapper of the system itoa.
 * @note CORE DEVELOPERS: please change this function and its implementation if
 * you want to convert longer interger---this is very easy.
 *
 * Be aware this function can only convert non-negative integer.
 *
 * @param source The original integer you want to convert.
 * @param target The result as a uint8_t array.
 *
 * @return None.
 */
void AmuletITOA(int16_t source, __char_array target, uint8_t requestor);

/**
 * Concat the second string to the end of the first string
 *
 * @param target The original string will be modified.
 * @param to_add The string will be appended to the original string.
 *
 * @return None.
 */
void AmuletConcat(__char_array target, __char_array to_add, uint8_t requestor);
/**
 * Composes a string with the same text that would be printed if format was used
 * on printf, but instead of being printed, the content is stored as a C string
 * in the 'target' buffer.
 *
 * @note AmuletSprintf is a custom verson of sprintf for Amulet.
 *
 * @param target A character array where the resulting string is stored.
 * @param fmt The desired C string style format string.
 *
 * @return None.
 */
void AmuletSprintf(__char_array target, __char_array fmt, ...);

/**
 * Return the RR interval(1/1024s) as 16 bit unsigned integer
 */
uint16_t AmuletGetRR(uint8_t requestor);

/**
  Return the HR, RRI intervals(1/1024s)(up to seven of them),
  Energy, and skin Contact as 16 bit unsigned integer.  Valid
  values for idx are:
    HRM_HR = 0,
    HRM_RRI1 = 1,
    HRM_RRI2 = 2,
    HRM_RRI3 = 3,
    HRM_RRI4 = 4,
    HRM_RRI5 = 5,
    HRM_RRI6 = 6,
    HRM_RRI7 = 7,
    HRM_ENERGY = 8,
    HRM_CONTACT = 9
  or the integers associated with those enum values.
*/
uint16_t AmuletGetHRandRRI(uint8_t idx, uint8_t requestor);

/**
 * Calculate standard deviation of an array of floats.
 *
 * @return standard deviation.
 */
float AmuletGetStdDev(__float_array rrs, float total_time, uint8_t numBeats,
                      uint8_t requestor);

/**
 * Generate a psuedo-random number.
 *
 * @return psuedo-random number.
 */
uint16_t AmuletRand(uint16_t seed, uint8_t requestor);

/**
 * Converts a null-terminated string to a float.
 *
 * @return float number represented by the input string.
 */
float AmuletStringToFloat(__char_array source, uint8_t requstor);

/**
 * AmuletITOA is merely a wrapper of the system itoa.
 *
 * @return integer number represented by the input string.
 */
uint16_t AmuletATOI(__char_array source, uint8_t requstor);

/**
 * Converts a float to a null-terminated string.
 *
 * @return none.
 */
void AmuletFloatToString(float value, __char_array target, uint8_t requestor);

/**
 * Seconds since the amulet started up
 */
uint32_t AmuletSeconds(uint8_t requestor);
#endif /* AMULET_H */